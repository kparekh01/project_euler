# The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
#
# 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
#
# Let us list the factors of the first seven triangle numbers:
#
#  1: 1
#  3: 1,3
#  6: 1,2,3,6
# 10: 1,2,5,10
# 15: 1,3,5,15
# 21: 1,3,7,21
# 28: 1,2,4,7,14,28
# We can see that 28 is the first triangle number to have over five divisors.
#
# What is the value of the first triangle number to have over five hundred divisors?

require 'benchmark'
require 'bigdecimal/math'
require "prime" #using module methods takes (  8.105043) my method freezez the comp, must refactor!

puts Benchmark.measure {
  def triangle_num(num)
    (1..num).to_a.inject(:+)
  end
  i = 2
  while i < 1000000
      if Prime.prime_division(triangle_num(i)).inject(:+).map.each_with_index{|val, index| val + 1 if index.odd? == true}.compact.inject(:*) >= 500
         p triangle_num(i) #76576500
         break
      end
  i += 1
  end
  # while loop will take the Prime.prime_division of the triangular number of i ([prime, exp]), add 1 to the exponents(odd index), and multiply them(total factors)
  # if the factors for that number come out to be over 500 print that triangular number, and break the loop.
  # comeback to see if code can be optimized to run faster.

  # def factors(n)
  #   results = [1]
  #   a = 2
  #   while a <= n
  #     if (n % a == 0)
  #       results << a
  #     end
  #   a += 1
  #   end
  #   return results
  # end
  #
  # num = 1
  # counter = 1
  # while (factors(num).count < 501)
  #   counter += 1
  #   num = (num + counter)
  # end
  # p num <-- takes way too long, must refactor.

}
#execution times may vary from computer to computer, but on my mac it took (  8.105043) seconds to execute.
